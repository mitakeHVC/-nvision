import pytest
import pytest_asyncio
import uuid
import json
from datetime import datetime
from unittest.mock import AsyncMock, MagicMock, patch

from src.repositories.client_preference_repository import ClientPreferenceRepository
from src.data_models.client_preferences_models import ClientPreference, ClientPreferenceCreate, ClientPreferenceUpdate
# Assuming Neo4jConnector is the class to mock for DB interaction.
# Actual driver components like AsyncSession, AsyncTransaction, Result might not be needed
# if we mock the connector's execute_query method directly.
from src.neo4j_utils.connector import Neo4jConnector


@pytest.fixture
def mock_neo4j_connector():
    connector = MagicMock(spec=Neo4jConnector)
    # Mock the primary method used by the repository to interact with the database
    connector.execute_query = AsyncMock()
    return connector

@pytest.fixture
def preference_repository(mock_neo4j_connector):
    # Patch the _ensure_constraints method as it tries to run queries on init
    with patch.object(ClientPreferenceRepository, '_ensure_constraints', return_value=None):
        repo = ClientPreferenceRepository(neo4j_connector=mock_neo4j_connector)
    return repo

# --- Test Cases will be added below ---

@pytest_asyncio.fixture
async def sample_client_id():
    return str(uuid.uuid4())

@pytest_asyncio.fixture
async def sample_preference_id():
    return str(uuid.uuid4())

@pytest_asyncio.fixture
async def sample_create_data(sample_client_id):
    return ClientPreferenceCreate(
        client_id=sample_client_id,
        preferences_payload={"theme": "dark", "notifications": {"email": True, "sms": False}}
    )

@pytest_asyncio.fixture
async def sample_db_record(sample_preference_id, sample_create_data):
    now = datetime.utcnow()
    # This simulates the structure of a Neo4j node record returned by the driver
    # The repository's _node_to_preference method would handle this.
    # For now, let's assume execute_query returns a list of dicts where each dict is a node.
    return {
        "id": sample_preference_id,
        "client_id": sample_create_data.client_id,
        "preferences_payload": sample_create_data.preferences_payload, # Assuming payload stored as dict/map
        "created_at": now.isoformat(),
        "updated_at": now.isoformat(),
        "created_by": "test_user",
        "last_updated_by": "test_user",
        "version": 1,
        "is_deleted": False
    }

# Test for creating a preference
@pytest.mark.asyncio
async def test_create_preference(preference_repository: ClientPreferenceRepository,
                                 mock_neo4j_connector: MagicMock,
                                 sample_create_data: ClientPreferenceCreate,
                                 sample_db_record: dict):

    # Configure the mock_neo4j_connector.execute_query to simulate returning the created node
    # The actual repository's create method wraps the returned data in a ClientPreference object.
    # The mock should return a list containing a dictionary, where the key "cp" holds the node data.
    mock_neo4j_connector.execute_query.return_value = [{"cp": sample_db_record}]

    created_by_user = "test_user"
    created_preference = await preference_repository.create(sample_create_data, created_by=created_by_user)

    assert created_preference is not None
    assert isinstance(created_preference, ClientPreference)
    assert created_preference.client_id == sample_create_data.client_id
    assert created_preference.preferences_payload == sample_create_data.preferences_payload
    assert created_preference.id is not None # Should be generated by the repo or DB
    assert created_preference.created_at is not None
    assert created_preference.updated_at is not None

    # Assert that execute_query was called.
    # We might need to be more specific about the query string and params if we want to verify those.
    mock_neo4j_connector.execute_query.assert_called_once()
    call_args = mock_neo4j_connector.execute_query.call_args
    query_string = call_args[0][0]
    params_dict = call_args[0][1]

    assert "CREATE (cp:ClientPreference $props)" in query_string
    assert "props" in params_dict
    assert params_dict["props"]["client_id"] == sample_create_data.client_id
    assert params_dict["props"]["preferences_payload"] == sample_create_data.preferences_payload
    assert params_dict["props"]["created_by"] == created_by_user


@pytest.mark.asyncio
async def test_get_by_id_found(preference_repository: ClientPreferenceRepository,
                               mock_neo4j_connector: MagicMock,
                               sample_preference_id: str,
                               sample_db_record: dict):
    mock_neo4j_connector.execute_query.return_value = [{"cp": sample_db_record}]

    preference = await preference_repository.get_by_id(sample_preference_id)

    assert preference is not None
    assert isinstance(preference, ClientPreference)
    assert preference.id == sample_preference_id
    assert preference.client_id == sample_db_record["client_id"]
    assert preference.preferences_payload == sample_db_record["preferences_payload"]

    mock_neo4j_connector.execute_query.assert_called_once()
    call_args = mock_neo4j_connector.execute_query.call_args
    query_string = call_args[0][0]
    params_dict = call_args[0][1]
    assert "MATCH (cp:ClientPreference {id: $preference_id, is_deleted: false})" in query_string
    assert params_dict["preference_id"] == sample_preference_id


@pytest.mark.asyncio
async def test_get_by_id_not_found(preference_repository: ClientPreferenceRepository,
                                   mock_neo4j_connector: MagicMock,
                                   sample_preference_id: str):
    mock_neo4j_connector.execute_query.return_value = [] # Simulate no record found

    preference = await preference_repository.get_by_id(sample_preference_id)

    assert preference is None
    mock_neo4j_connector.execute_query.assert_called_once_with(
        "MATCH (cp:ClientPreference {id: $preference_id, is_deleted: false}) RETURN cp LIMIT 1",
        {"preference_id": sample_preference_id}
    )


@pytest.mark.asyncio
async def test_get_by_client_id_found(preference_repository: ClientPreferenceRepository,
                                      mock_neo4j_connector: MagicMock,
                                      sample_client_id: str,
                                      sample_db_record: dict):
    # Ensure the sample_db_record uses the sample_client_id for this test
    sample_db_record["client_id"] = sample_client_id
    mock_neo4j_connector.execute_query.return_value = [{"cp": sample_db_record}]

    preference = await preference_repository.get_by_client_id(sample_client_id)

    assert preference is not None
    assert isinstance(preference, ClientPreference)
    assert preference.client_id == sample_client_id
    assert preference.id == sample_db_record["id"]

    mock_neo4j_connector.execute_query.assert_called_once()
    call_args = mock_neo4j_connector.execute_query.call_args
    query_string = call_args[0][0]
    params_dict = call_args[0][1]
    assert "MATCH (cp:ClientPreference {client_id: $client_id, is_deleted: false})" in query_string
    assert params_dict["client_id"] == sample_client_id


@pytest.mark.asyncio
async def test_get_by_client_id_not_found(preference_repository: ClientPreferenceRepository,
                                          mock_neo4j_connector: MagicMock,
                                          sample_client_id: str):
    mock_neo4j_connector.execute_query.return_value = [] # Simulate no record found

    preference = await preference_repository.get_by_client_id(sample_client_id)

    assert preference is None
    mock_neo4j_connector.execute_query.assert_called_once_with(
        "MATCH (cp:ClientPreference {client_id: $client_id, is_deleted: false}) RETURN cp LIMIT 1",
        {"client_id": sample_client_id}
    )

@pytest.mark.asyncio
async def test_update_preference_found(preference_repository: ClientPreferenceRepository,
                                       mock_neo4j_connector: MagicMock,
                                       sample_preference_id: str,
                                       sample_db_record: dict):
    update_data = ClientPreferenceUpdate(preferences_payload={"theme": "light", "language": "en"})
    updated_by_user = "update_user"

    # Simulate the structure for the updated record
    # In a real scenario, only preferences_payload, updated_at, last_updated_by, version would change
    updated_record_from_db = sample_db_record.copy()
    updated_record_from_db["preferences_payload"] = update_data.preferences_payload
    updated_record_from_db["last_updated_by"] = updated_by_user
    updated_record_from_db["version"] = sample_db_record["version"] + 1
    updated_record_from_db["updated_at"] = datetime.utcnow().isoformat() # Will be different

    mock_neo4j_connector.execute_query.return_value = [{"cp": updated_record_from_db}]

    updated_preference = await preference_repository.update(sample_preference_id, update_data, updated_by_user)

    assert updated_preference is not None
    assert isinstance(updated_preference, ClientPreference)
    assert updated_preference.id == sample_preference_id
    assert updated_preference.preferences_payload == update_data.preferences_payload
    # We can't assert exact updated_at, but can check it's newer or close to now
    assert (datetime.utcnow() - datetime.fromisoformat(updated_record_from_db["updated_at"])).total_seconds() < 5


    mock_neo4j_connector.execute_query.assert_called_once()
    call_args = mock_neo4j_connector.execute_query.call_args
    query_string = call_args[0][0]
    params_dict = call_args[0][1]

    assert "MATCH (cp:ClientPreference {id: $preference_id, is_deleted: false})" in query_string
    assert "SET cp.updated_at = $updated_at, cp.last_updated_by = $updated_by, cp.version = cp.version + 1" in query_string
    assert "cp.preferences_payload = $preferences_payload" in query_string
    assert params_dict["preference_id"] == sample_preference_id
    assert params_dict["preferences_payload"] == update_data.preferences_payload
    assert params_dict["updated_by"] == updated_by_user

@pytest.mark.asyncio
async def test_update_preference_not_found(preference_repository: ClientPreferenceRepository,
                                           mock_neo4j_connector: MagicMock,
                                           sample_preference_id: str):
    update_data = ClientPreferenceUpdate(preferences_payload={"theme": "light"})
    updated_by_user = "update_user"

    mock_neo4j_connector.execute_query.return_value = [] # Simulate node not found for update

    updated_preference = await preference_repository.update(sample_preference_id, update_data, updated_by_user)

    assert updated_preference is None
    mock_neo4j_connector.execute_query.assert_called_once()


@pytest.mark.asyncio
async def test_delete_preference_found(preference_repository: ClientPreferenceRepository,
                                       mock_neo4j_connector: MagicMock,
                                       sample_preference_id: str):
    deleted_by_user = "delete_user"
    # Simulate a successful delete (e.g., count of deleted nodes is 1)
    mock_neo4j_connector.execute_query.return_value = [{"count": 1}]

    success = await preference_repository.delete(sample_preference_id, deleted_by_user)

    assert success is True
    mock_neo4j_connector.execute_query.assert_called_once()
    call_args = mock_neo4j_connector.execute_query.call_args
    query_string = call_args[0][0]
    params_dict = call_args[0][1]
    assert "MATCH (cp:ClientPreference {id: $preference_id, is_deleted: false})" in query_string
    assert "SET cp.is_deleted = true, cp.deleted_at = $deleted_at, cp.last_updated_by = $deleted_by" in query_string
    assert params_dict["preference_id"] == sample_preference_id
    assert params_dict["deleted_by"] == deleted_by_user


@pytest.mark.asyncio
async def test_delete_preference_not_found(preference_repository: ClientPreferenceRepository,
                                           mock_neo4j_connector: MagicMock,
                                           sample_preference_id: str):
    deleted_by_user = "delete_user"
    # Simulate a failed delete (e.g., count of deleted nodes is 0)
    mock_neo4j_connector.execute_query.return_value = [{"count": 0}]

    success = await preference_repository.delete(sample_preference_id, deleted_by_user)

    assert success is False
    mock_neo4j_connector.execute_query.assert_called_once()
